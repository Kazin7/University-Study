게임의 분류
-플랫폼별 게임 분류
--온라인 게임(WoW)
--아케이드 게임(bubble bobble)
--pc 게임
--비디오(콘솔)게임(Xbox,Wii)
--모바일 게임

-장르별 게임 분류
--슈팅게임(FPS)
--액션게임(격투게임)
--RPG(로스트아크)
--어드벤처 게임(탐험 게임)
--실시간 전략 게임(스타)
--시뮬레이션 게임(심시티)
--보드게임(바둑,오목)

게임에 필요한 컴퓨터 기술
-프로그래밍
-자료구조 + 알고리즘 : 최적화
-DirectX 프로그래밍
-네트워크 기술
-데이터베이스 기술
-게임 물리 기술
-인공지능 기술

OpenGL
-상대적으로 느린 버젼업
-연구자 또는 비 윈도우 플랫폼 전용 3D라이브러리로 전락
-안드로이드 등장으로 빠르게 발전중

DirectX
-1996년 3.0부터 일반에 공개
-5.0까지는 openGL에 비해 경쟁력이 낮지만 6.0부터 더 나은 성능을 보인다.

게임엔진 구성요소
-렌더링 엔진 :3차원 가상공간을 2차원에 그리는 역할
-물리 엔진 : 가상공간의 물체들이 물리법칙에 따라 움직이도록 하는 것

영화 : 품질
게임 : 속도

======================================================
player = GameObject.FindGameObjectWithTag("Player").GetComponent<script>();
public GameObject[] prefabs;
gm = GameObject.Instantiate(prefab);

Awake : 물체가 처음 생성됐을때
OnEnable : 물체가 활성화됐을때
Start : Scene에 등장한 모든 물체가 생성완료됐을 때
Update : 매 프레임 시작때마다
Late Update : 모든 게임오브젝트의 Update처리가 끝난후 자동 실행

enum : 열거형 타입 , 값을 의미있는 예약어로 대치 지정하지 않을경우 이전값 + 1
NUM : 코딩에 의미있는 상태의 갯수

public enum STEP{
	NONE = -1,
	RUN = 0,
	JUMP,
	MISS,
	NUM,
};

Linecast() : 정해진 두지점 사이를 선으로 연결하여 그사이에 물체가 있는지 여부를 판단
Physics.Linecast(position,position,out hit)
GetComponent<Rigidbody>().velocity;

ref & out
-둘다 call by reference 수행 : 매개변수의 값이 함수 내에서 변경되면 함수가 종료되어 돌아와도 변경된 상태
-out으로 지정된 매개변수는 초기화하지않는다.
-out으로 지정된 매개변수를 받는 함수는 반드시 변수에 값을 반환해야한다.
======================================================================
this.transform.Translate();
this.transform.Rotate(a,a,a);

Input Manager설정
Name 설정 float a = Input.GetAxis(Name);
Alt Negative Button
Alt Positive Button
Gravity : 입력을 중지했을때 중립으로 돌아가는데 걸리는 시간
Dead : 값보다 작으면 입력을 무시하고 중립으로 처리
Sensitivity : 양 또는 음의 방향으로 이동할 속도 지정
Snap : 양과 음의 방향 버튼을 동시에 눌렀을 때 중립으로 처리

prefab은 관습적으로 Transform타입으로 선언
일반 물체와 구분하기 위해서, GameObject로 선언해도 동일하게 동작

포탄의 궤적 표현
포탄 Prefab에서 Trail Renderer추가
Is Trigger : 다른 물체와 충돌해도 물리적인 반응을 수행하지 않는다.

OnCollisionEnter(Collision col)
-충돌한 물체중 최소 하나는 Is Kinematic이 꺼져있어야함
-유니티 자체적으로 물리적인 반응 계산
-계산량이 많다.
-col에 담긴 정보 : 상대 물체의 정보 , 충돌지점, 충돌지점의 표면방향등

OnTriggerEnter(Collider col)
-충돌한 물체 중 하나라도 Trigger속성을 가진 경우
-충돌 후 물리 반응을 계산하지 않고 서로 관통
-계산량이 적다.
-col에 담긴 정보 : 상대 물체의 정보

태그 추가하는 법
Inspector에서 태그 항목에서 Add Tag선택 한뒤 추가
if(col.gameObject.tag == "tag")

특정 부분에서 소리나게 하기
AudioSource.PlayClipAtPoint(sound , position);

파티클
hierarchy -> Effects -> Particle System

[SerializeField] : 바로 다음의 private 변수를 Inspector에 보이게 한다.
this.transform.LookAt(target);

레이캐스트
RaycastHit hit;
if(Physics.Raycast(반직선 시작점, 반직선 방향, out hit, 반직선 길이)
Debug.DrawRay(반직선 시작점,반직선 방향*길이,Color.green);
hit.collider.gameObject.tag == "tag"

Quaternion.identity : 회전 초기값 

Global좌표계
-전체 공간에 공통으로 적용되는 좌표계

Local좌표계
-오브젝트를 기준으로 한 좌표계
-오브젝트의 이동 및 회전할 떄 사용, 회전시 Global과 달리 좌표축의 방향이 바뀜

Raycast() : Global좌표계 사용
-transform.TransformDirection(Vector3.forward) : Local 방향을 Global좌표에서의 방향으로 변환

transform.RotateAround(Vector3.zero , Vecotr3.up,angle * Time.deltaTime);

NavMesh설정
Window -> AI -> Navigation
Agents-> Areas -> Object -> Bake순
Agents : 캐릭터가 움직이는 형태 구분
Areas : 이동 가능, 불가능 구역 및 비용 지정
Object : 물체별 NavMesh 적용여부 및 Area선택
Bake : Navigation Mesh생성

Area와 Cost : 특정 지역을 지나가는데 필요한 비용
Navigation Static : 현재 선택된 물체를 기반으로 경로 탐색할 것인지

Agent Raius : 캐릭터가 통과할 수 있는 최대 너비 반지름
Agent Height : 캐릭터가 움직일 수 있는 최대 높이
Max Slope : 올라갈 수 있는 경사로 각도
Step Height : 계단과 같은 물체를 오를 수 있는 최대 높이

Off Mesh Link : 직접적으로 연결되어 있지 않은 NavMesh사이를 이동
-Jump Distance : 두물체 사이의 거리보다 작으면 Off Mesh Link가 생성되지 않는다.
-Drop Height : 지정된 물체에서 바닥으로 뛰어내리는게 가능한 높이

Nav Mesh Agent추가
Component -> Navigation -> Nav Mesh Agent
Steering
Stopping Distance : 목표 지점에 얼마나 가까워지면 멈출 것인지
Auto Braking : 목표지점에 가까워질 때 서서히 멈출 것인지

Obstacle Avoidance
Radius : 장애물을 피할 떄 근접 가능한 거리
Height : 장애물을 피할때 근접 가능한 높이
Priority : 우선순위보다 낮은 값은 피하지 않음

Path Finding
Auto Traverse Off Mesh Link : 연결되지 않은 지역간에 자동으로 경로탐색 진행 여부
Area Mask : 현재 물체가 갈수있는 지역들

코드에서 NavMeshAgent
public UnityEngine.AI.NavMeshAgent agent;
agent.SetDestination(target.transform.position); : 타겟을 쫓아감

static변수 : 클래스 자체에 속한 변수 , 게임 자체 내에서 공유되는 변수 값을 유지하고 싶을 때 사용
void OnGUI(){
	GUI.Label(new Rect(0,0,0,0),message);
}

상위 계층 오브젝트를 탐색하여 제거
Destroy(other.transform.root.gameObject);

=============================================================
Terrain
Hierarchy -> 3D Object -> Terrain
Brush Size : 영향을 끼치는 범위
Opacity : 누르는 효과의 강도
높이를 낮추려면 shift + 드래그

Brush 설정 옵션
-Brush Size : 브러쉬 굵기
-Tree Density : 드래그할때 나무가 밀집되는 정도
-Tree Height : 심어지는 나무의 높이 랜덤 체크시 랜덤
-Lock Width to Height : 나무의 너비와 높이 비율 유지
-Random Tree Rotation : 무작위로 나무를 회전

밤송이가 과녁에 닿는 순간 모든 물리력 무효화
void OnCollision(Collision other){
	GetComponent<Rigidbody>().isKinematic = true;
	GetComponent<ParticleSystem>().Play();
}

Ray screen_ray = Camera.main.ScreenPointToRay(Input.mousePosition);
-스크린 좌표를 받아서 카메라에서 스크린 좌표로 향하는 월드 좌표계 방향 반환
Vector3 shoot_ray = screen_ray.direction;
bamsongi.GetComponent<BamsongiCtrl>().Shoot(shoot_ray * 1000);

