Transform
-Position
-Rotation
-Scale

조명
Point Light
-사방으로 퍼져나가는 빛 ,거리가 멀수록 빛의 세기 감소

Directional Light
-방향만존재, 어디서든 빛의 세기가 일정

Spot light
-정해진 위치에서 일정 방향으로 퍼져나가는 빛

Insepctor에 나타나기 위해선 public 전역변수로 설정해야 한다.

변수 : 소문자로 시작
함수 및 클래스: 대문자로 시작

Start
-스크립트가 연결된 물체가 처음 Scene에 등장할 때 실행

Update
-매 프레임마다 실행, 스크립트 연결된 물체가 활성화되어 있어야 함

Input.GetAxis("Horizontal");
-> a = -1  , d = 1

Input.GetAxis("Vertical");
-> w = 1  , s = -1

Input.GetAxisRaw()
-> -1,0,1 만 반환하지만 입력 반응이 빠르다

if(Input.GetKey(KeyCode.F1))

Input.GetKeyDown(KeyCode)
-> 특정 키가 눌린 순간에만

Input.GetKeyUp(KeyCode)
-> 특정 키에서 손가락이 떨어진 순간에만

Input.anyKeyDown
-> 아무 키나 눌린 순간에만

Input.GetMouseButtonUp(btn)
->btn이 0 -> 왼쪽 1->오른쪽 2->휠

Input.mousePosition
->현재 마우스 포인터의 위치를 반환 왼쪽아래가 0,0

물체 이동
this.transform.Translate(vector3)
this.transform.position = vector3

회전
this.transform.Rotate(90*Time.deltaTime,0,0) -> 1초에 90도 회전
this.transform.rotation = Quaternion.Euler(0,0,0);

축소확대
this.transform.localScale = Vector3()

랜덤함수
float rnd = Random.Range(0,2);

Time.deltaTime
-직전 프레임과 현재 프레임 사이의 소요시간
매프레임 이동거리 = 속도 * Time.deltaTime

Vector3.foward = Vector3(0,0,1)
Vector3.right = Vector3(1,0,0)
Vector3.up = Vector3(0,1,0)
Vector3.zero = Vector3(0,0,0)

Rigidbody
-Is Kinematic : 물체에 가해지는 힘의 크기와 방향을 계산하지 않는다. Transform을 통해서 조작 가능

PhysicFrame
-여러가지 충돌이나 물리 반응 등을 통해 물체를 움직이는 기준 시간

Rendering Frame
-각 물체들을 화면에 그려주는 기준 시간

두개는 항상 일치하지는 않는다.

Interpolate
-물체의 움직임이 지나치게 끊겨 보일 경우 사용한다.
-물체의 연속된 움직임을 계산하는 방식

Discrete
-현재 프레임의 위치만으로 충돌 검사
-터널링 문제 발생

Continuous
-이전 프레임과 현재 프레임 사이의 이동 궤적을 바탕으로 충돌 검사
-rigidbody를 가진 물체엔 discrete검사 없는 물체에는 continuous검사

Continous Dynamic
-Continous나 Continous Dynamic Rigidbody가 없는 물체에 Continous적용
-Discrete가 적용된 물체에는 Discrete 충돌 검사
-계산량이 많다.

constraints : 외력에 의한 움직임에 제약을 준다
-Freeze Position : 선택된 축 방향으로 이동 불가
-Freeze Rotation : 선택된 축을 중심으로 회전 불가

텍스쳐 원본의 색을 유지하려면 shader변경
-Unlit/Texture

Audio Clip
-배경음악이나 효과음 등이 수록된 사운드 파일

Audio Source
-물체에 Audio Clip을 연결하고 처리하는 컴포넌트

Play On Awake : 연결된 물체의 등장과 함께 소리 재생
Loop: 반복 재생
Priority : 우선순위
Pitch : 재생 속도

충돌 이벤트 처리
OnCollisionEnter(Collision other) : 스크립트가 연결된 물체에 충돌 발생시 호출되는 함수
OnCollisionStay(Collision other) : 충돌이 유지되고 있는 동안의 이벤트 처리
OnCollisionExit(Collision other) : 충돌이 유지되고 있다가 끝나느 순간의 이벤트 처리
if(other.gameObject.name == "Sphere")
	ball.GetComponent<Rigidbody>().AddForce(new Vector3(10, 500, 300));

사운드 재생
this.GetComponent<AudioSource>().Play();

충돌이벤트 발생 조건
-두 물체는 모두 Collider를 보유하고 있어야한다.
-두 물체중 적어도 하나는 Rigidbody를 보유하고 있어야 한다.

부모 자식 연결
GameObject gm = GameObject.Find("Cube") as GameObject;
gm.transform.parent = this.transform;

GameObject.Find()
-가장 최근에 추가된 물체부터 검색한다.
-계산량이 많아서 start에서 사용하는 것을 추천한다

as GameObject
-찾은 대상을 GameObject형식으로 반환
-Find()는 GameObject형식이라 안써도된다

GameObject gm = GameObject.Instatntiate(prefab) as GameObject;

OnGUI(){ -> 매프레임 마다 호출 GUI클래스 함수들은 여기 안에서만 동작한다
	GUI.DrawTexture(new Rect(0,0,0,0) , icon);
	GUI.Label(new Rect(0,0,0,0) , count.ToString());
}

using UnityEngine.SceneManagement;
SceneManager.LoadScene("Sample Scene");

RigidbodyConstraints
-Rigidbody가 있는 물체의 움직임에 제약을 부여
-FreezeAll , FreezePositionX , FreezeRotationX

IEnumerator Start() -> 해당 함수의 쓰레드를 생성하여 별도로 동작시킴

WaitForSeconds(1.5f)
yield return new WaitForSeconds(interval);
-반드시 yield , IEnumerator 와 함께 사용한다
-현재 프레임이 끝난후 1.5초 뒤에 이 함수를 호출한 함수를 다시 호출

Destroy(gameObject , 5.0f);
5초뒤 자동 제거

