상속 예외처리 가상함수 추상화 프렌드함수 연산자재정의 파일입출력

복사생성자
Book::Book(Book&b)

Book cpp;
Book java = cpp;//복사생성자사용

동적할당
int *p;
p = new int[n];
delete [] p; //꼭 중간에있어야됨

상속
class Book : public Product
Book(int id , string info , int price , string isbn , string title) : Product(id,info,price)
//부모생성자를 이용해 초기화가능

순수 가상함수
virtual double getArea() = 0;//순수가상함수

정적변수
double Ellipse::PI(3.141592);//정적변수 파이값을 초기화

템플릿
template <class T>//템플릿을 사용하여 제너릭 이용

void Swap(T &a , T &b){//주소로 받아와서 두개를 바꿔주는 제너릭 함수
	T temp = a;//임시 변수를 이용하여 값을 변경
	a = b;
	b = temp;
}
template <class T>
T MyStack<T>::pop(){//값을 리턴하는 함수
	if(tos <= 0){//0보다 작을경우
		cout << "Stack Empty";//스택이 비어있음
		return 0;//종료
	}
	else{//그외의 경우
		tos--;//1감소
		return Stack[tos];//스택에 있는 데이터 리턴
	}
}
MyStack<double> st1;
스택 push 넣고 인덱스 증가
       pop 인덱스 감소후 출력

리스트,iterator
#include<list>
#include<iterator>

list<int> myList;
myList.push_back(200);
myList.push_front(50);
list<int>::iterator iter;
for(iter = myList.begin() ; iter != myList.end() ; iter++){
		cout << *iter << "  ";//주소를 이용하여 값을 출력
}
myList.sort();//리스트 정렬
myList.size();//원소 갯수 출력
myList.clear();//모두 삭제

map
#include<map>

map<string , string> dic;//맵선언
dic.insert(make_pair(word , mean));//insert를 이용하여 사전에 단어를 추가한다
dic.erase(word);//erase함수를 이용하여 사전에 있는 단어를 삭제한다
return dic[word];//word가 의미하는 뜻을 리턴한다
map<string , string> :: iterator iter;//iterator를 이용하여 맵에있는 내용을 전부 출력한다
	for(iter = dic.begin() ; iter != dic.end() ; iter++){
		cout<<"단어 : "<<(*iter).first<<" , "<<"의미 : "<<(*iter).second<<endl;
	}

cout설정

cout.setf(ios::fixed);//소숫점이 표현되도록 설정
cout.precision(4);//소숫점이 4자리만 표현되도록 설정

cout.setf(ios::hex ,ios::basefield);//16진수로 출력 설정을 바꾼다
cout.setf(ios::showbase);
cout << "HEX : " << num << endl;//16진수 출력

cout.setf(ios::oct ,ios::basefield);//8진수로 출력 설정을 바꾼다
cout.setf(ios::showbase);
cout << "OCT : " << num << endl;//8진수 출력

연산자 중복정의
1.
Book& operator +=(int price);
Book& Book::operator +=(int price){
	this->price = this->price + price;
	return *this;
}
Book a += 500;
2.
friend bool operator ==(Book book , int price);
bool operator ==(Book book , int price){
	if(book.price == price)
		return true;
	else
		return false;
}
friend Circle& operator ++(Circle& c);//프렌드 연산자 중복정의 ->전위
friend Circle operator ++(Circle& c , int x);//연산자 중복정의 ->후위

Circle& operator++(Circle& c) {//전위계산할때 사용하는 연산자
	c.radius = c.radius + 1;//값을 1증가시킨다
	return c;//객체 주소 리턴
}
Circle operator++(Circle& c , int x){//후위 계산할때 사용하는 연산자
	Circle d ;//객체 하나 생성
	d.radius = c.radius;//반지름 저장
	c.radius = c.radius + 1 ;//c의 값을 1증가
	return d;//먼저 저장한 객체 리턴
}
friend ostream& operator << (ostream& outs , Circle c);//연산자를 재정의 하기위한 함수
friend istream& operator >> (istream& ins , Circle &c);

ostream& operator << (ostream& outs, Circle c) {//<<연산자를 재정의하는 함수
	outs << "(반지름이 " << c.radius << "인 " << c.getName() <<"의 면적 " << c.getArea() << ")";
	return outs;//스트림 반환
}
istream& operator >> (istream& ins , Circle &c){//>>연산자를 재정의하는 함수
	cout << "반지름 >>";//반지름과 이름을 받는다
	ins>> c.radius;
	cout << "이름 >>";
	ins >> c.name;
	return ins;//스트림 반환
}

파일 입출력
#include<fstream>

ofstream fout; //파일에 저장하기 위해 여는 스트림
fout = open(filename);

if(!fout)//파일 열기 실패 처리

fout << "파일명" << fname <<endl; //파일에 저장

ifstream fin;//파일을 읽어오기 위해 여는 스트림
fin = open(filename , ios::out | ios::binary);
if(!fin)//파일 열기 실패 처리

char buf[100];
while(fin.getline(buf , 100))//한줄에 최대100문자씩 읽어온다
	cout << buf << endl;
int c;
while((c = fin.get()) != EOF)
	fout.put(c);

ios::in , ios::out , ios::binary , ios::app
-출력 , 입력 , 이진 , 추가입력
fout.write((char*)&p , sizeof(phone));//받은 값을 파일에 저장한다

while(!fin.eof()){//파일의 끝에 도달할때까지 반복
	fin.read((char*)&p , sizeof(phone));//객체 사이즈만큼 읽어온다
				
	if(p.getName() == fname){//객체의 이름과 찾는이름이 같을경우
		cout << p;//그 객체의 정보를 출력한다
		break;//while문 종료
	}
}
while(!fin.eof()){//파일의 끝에 도달할때까지 반복
	fin.read((char*)&p , sizeof(phone));//객체사이즈만큼 읽어온다
	cout << p << endl;//읽어온 객체를 출력 -> 전화번호부에 존재하는 모든 객체 출력
}
트라이 캐치

try{
	if(!fin.is_open()){//만약 파일이 열리지 않았을경우
		throw FileIOException(27 ,"파일을 찾을 수 없습니다.");//throw를 이용하여 클래스 호출
		}
	}catch(FileIOException &e){//받아온 클래스 객체에서 오류메세지를 출력하는 함수 호출
		e.toString();
}